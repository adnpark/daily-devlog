'메모리에 남지 않는 문자열'을 보고 배운 점과 의문

곧 토스 개발자 컨퍼런스인 'SLASH 22'가 열린다는 광고를 봤다. 한번도 본적이 없었기 때문에 어떻게 진행되나, 궁금해서 작년 영상을 봤다. 

당연히 iOS 관련 발표 영상에 먼저 눈이 갔다. '메모리에 남지 않는 문자열'이라는 영상이었다. 메모리와 문자열 둘 다 내가 알고 있는 단어인데, 조합이 신선했다. 

별 기대 없이 봤는데 중요한 개념들이 꽤 나와서, 내가 몰랐던 키워드들도 알게 되고, 헷갈리는 부분도 있어서 몇번 반복해서 보면서 며칠 간 공부를 하는 좋은 계기가 되었다.

중요한 개념들이 꽤 나왔고, 내가 몰랐던 기술도 있었다.

덕분에 Swift의 문자열과 메모리에 대해 공부하는 좋은 계기가 되었다.

세션 내용은 여기 공개돼있다. 이 글에서 발표 내용을 그대로 설명하진 않는다. 
이 발표를 이해하기 위해서 내가 공부한 지식과, 의문점을 주로 얘기하려고한다.

## 문제 개요

발표에서 해결하고자 하는 문제를 먼저 설명해야겠다. 토스는 금융 앱이니만큼 사용자의 개인정보 보안에 신경을 써야한다. 

앱에서 사용자가 입력한 비밀번호 같은 정보들은 당연하게도 메모리에 문자열(String) 타입으로 저장된다. 

그런데 이 메모리에 개인정보의 '흔적'이 남는다면 어떨까? 보안상 취약점이 된다. 해커가 메모리 전체를 Dump를 뜰 수 있다면, 메모리에 남아있는 비밀번호를 볼 수도 있는 것이다. 

물론 메모리를 안 사용할 수는 없다. 
하지만 메모리에 비밀번호의 흔적을 남기지 않을 수는 있다. 
그래서 세션 제목이 '메모리에 남지 않는 문자열'이다.

발표의 내용은 공개되어있으니, 발표의 내용을 따라가기보다는 이 세션을 이해하기 위해서 필요한 배경 지식과 궁금증에 대해서 정리하는 식으로 글을 풀려고 한다.

## String은 어디에 저장되는가?

문자열(String)이 어떻게 메모리에 저장될까?

Swift에서 데이터 타입은 크게 2가지로 나눈다. 
값 타입(Value type), 참조 타입(Reference type)이다.

동적으로 할당되는 메모리 영역은 2종류가 있다. 
스택(Stack)과 힙(Heap)이다.

Swift 기본 타입은 전부 값 타입(Value type)이다. 스택에 저장된다. 문자열도 마찬가지로 값 타입이다. 그럼 스택에 저장되겠지? 
하지만 아니다.

문자열(String), 배열(Array) 같이 여러 값이 묶여있는 타입들을 컬렉션(Collection)이라고 한다. Swift의 문자열은 '글자(Character)' 타입이 묶여있는 컬렉션이다.

컬렉션은 값 타입이지만, 동시에 데이터는 Heap에 저장된다. 보통은 스택에 저장되는 게 더 효율적이다. 하지만 이 경우엔 힙에 저장하면 2가지 장점이 있다.


**Copy-on-write를 통한 성능 최적화**

String이나 Array는 아주 많은 값을 담을 수 있다. 
String에 몇만 개의 글자가 들어갈 수 있다. Array에 수십, 수백만 개의 데이터가 들어갈 수 있다. 

이 값은 프로그램이 실행되면서 이 함수에서 저 함수로, 이 객체에서 저 객체로 자주 주고받게 된다. 그때마다 할당이 일어난다. 값 타입은 할당 시에 복사를 한다. 

값을 전달할 때마다 새로운 메모리를 할당하고, 복사하는 과정이 반복된다. 
이 복사 덕분에 값 타입은 '불변성'이라는 큰 메리트가 있다. 
하지만 복사가 많이 일어날 수 밖에 없다는 단점도 있다.

그래서 Swift는 많은 값이 담길 수 있는 컬렉션 데이터를 Heap에 저장한다. 
값을 할당할 때, Heap에 저장된 데이터의 참조를 공유한다. 
문자열이나 배열을 새로 할당할 때 복사가 일어나지 않는다.  
Heap에 있는 데이터에 접근할 수 있는 참조만 늘어날 뿐이다.

물론 값 타입Value type 특성인 불변성은 유지해야 한다. 

따라서 변경이 되었을 때는 새로운 값으로 복사를 한다. 

예를 들어보자. A 문자열을 B에 할당했다. B는 A와 같은 데이터의 참조를 공유한다. 그 다음 B 문자열에 변경이 일어났다. 그러면 B는 참조하는 데이터를 바꾸는 게 아니다. 새로운 복사본을 힙에 만든다.  그 값을 변경한다. A의 값은 아무런 영향도 받지 않는다.

할당할 때 복사가 아닌, 변경할 때 복사가 일어나는 방식이다. 이걸 Copy-on-write(COW)라고 한다. Swift는 COW를 적극적으로 쓴다. 덕분에 참조 타입Reference type의 효율성과 값 타입Value type의 불변성을 둘 다 잡을 수 있다.


**런타임에 데이터의 길이가 바뀔 수 있다.**

Stack 메모리의 특징은, 컴파일을 하는 시점에 미리 메모리를 얼마나 쓰게 될지 확정을 할 수 있어야 한다는 것이다. Stack은 마치 벽돌을 쌓듯이 메모리 공간을 배정한다. 메모리 공간의 할당도 선형적으로 이뤄진다. 중간중간 빈 공간이 없는 연속적인 할당이다. 

그렇기 때문에 Stack이 한번 쌓일 때 (Stack이 담당하는 Scope가 시작될 때) 그 안에 들어가게 될 메모리의 크기를 정확히 알아야 한다. 하나의 Stack이 올라갔을 때 그 크기를 확정할 수 있어야, 그 안에 있는 코드를 실행하면서 다음 스택이 쌓이게 되면, 다음 Stack이 생길 때 할당할 메모리를 알 수 있다. 어디서부터 어디까지 메모리를 할당할지 알 수 있어야 하기 떄문이다. 중간에 실행하다가 갑자기 메모리가 더 필요하다고 해서 공간을 늘릴수가 없는 구조다.

문자열, 배열 같은 컬렉션 타입에 할당된 메모리 크기가 고정이 되어있다면, 상당히 불편할 것이다. 문자열과 배열에 데이터를 추가하거나 삭제하는 것은 매우 흔한 일이다. 그걸 모두 예상해서 미리 메모리를 할당하는 건 어렵다.

데이터를 Heap에 저장하는 이유다. Heap은 순서대로 쌓이는 선형적인 메모리 구조가 아니다. 따라서 만약에 실행 중에 메모리 공간이 더 필요하면 새로 배정해주고 참조하는 주소만 바꿔주면 된다. 따라서 우리는 데이터 길이를 확정하지 않아도 얼마든지 런타임에 데이터를 추가하거나 삭제할 수 있다.

결론적으로 String은 Heap에 저장이 된다. 근데 그게 무슨 문제라는 거지?

## 메모리를 해제해도 데이터가 사라지는 게 아니라고?

Stack이나 Heap은 런타임에 동적으로 메모리를 할당하고 반납한다. 처음 변수를 생성할 때 메모리가 할당이 됐다가, 더 이상 해당 변수를 사용하지 않으면 메모리를 반납한다.

'사용하지 않는다'는 건 어떻게 할까? C 언어 같이 개발자가 수동으로 메모리를 관리해줘야 하는 언어라면, 직접 메모리 해제 명령을 넣어줄 것이다.

Swift는 '레퍼런스 카운팅'을 통해 '사용하지 않음'을 자동으로 판단하고 메모릐를 해제한다. 힙에 저장된 데이터를 가리키는 참조가 더 이상 없으면, 이 데이터의 사용이 끝났다고 판단하고 메모리를 회수한다.

여기까지는 나도 알고 있는 부분이었다. 이 발표를 들으면서 Garbage Value라는 개념을 처음 알았다. 이 메모리를 반납하는 과정에서 메모리에 담겨있는 데이터는 그대로 남아있다. 더 이상 프로세스에 의해서 참조되지 않을 뿐, 어쨌든 메모리에 바이트 값이 남아있다는 거다.

이게 바로 앞서 말했던 문자열의 '흔적'이다. 왜 추리 만화보면, 누군가 휘갈긴 메모를 뜯어냈는데, 그 밑의 종이에다가 막 색칠을 해서 무슨 글자를 썼었는지 알아내지 않는가? 아니면 우리가 도어락을 누르고 나서 묻어있는 지문을 보고 번호를 알아낸다든지?

우리가 알지 못하지만 문자열은 할당과 해제를 반복하면서 계속 흔적을 남기고 있었던 것이다. 그리고 만약 해커들이 메모리에 접근할 수 있다면 이건 정보 탈취를 위한 먹잇감이 될 수 있다.

사실 이 부분에선 좀 의문이 들었다. 나는 당연히 메모리를 '해제'한다는 건 거기있는 데이터를 싹 지우는 건 줄 알았는데, 그게 아니라 그냥 값을 남겨둔다니. 마치 PC방 가서 게임 아이디 로그아웃을 안하는 느낌이잖아? 검색을 해보니 다른 언어도 크게 다르지 않은 것 같은데 왜 그런지 이유를 잘 모르겠다. 불필요한 오버헤드라고 생각해서일까?

아무튼, 보안을 위해서는 그 불필요한 오버헤드가 필요하다. 메모리를 썼을 때 자동으로 데이터를 지우도록 만드는 게 이 발표에서 해결하고자 하는 문제였다.

## Associated Object

뭐 해결방법은 쉽다. 메모리를 해제하는 시점에 가비지 밸류를 삭제하는 코드가 실행되도록 하면 된다. 

근데... 어떻게 메모리를 해제하는 시점을 알아내지?

토스 개발자가 사용한 방법은 Assciated Objects 였다. 

이  Assciated Objects도 완전 처음 보는 개념이었다. Objective-c 언어에 있는 기능이기 때문이다.

물론 Swift는 obj-c 런타임과 호환이 되기 때문에 쓸 수 있다.

자세한 개념이나 인자값까지 설명할 필요는 없을 것 같다. 단순화시켜서 얘기해보면, '특정 객체'에 '연관 객체'를 붙여서 기능을 추가할 수 있다.

비유하자면 약간 도청기 같은 기능이다. 목표 객체가 무언가 액션을 하게 되면, 연관 객체도 특정한 액션을 실행하도록 할 수 있다.

Assciated Objects는 외부 라이브러리나 프레임워크에서 제공하는 객체의 코드를 수정하거나 상속하지 않고서 새로운 행동을 추가하고자 할때 쓸 수 있는 기법이다.

객체가 원래 갖고 있지 않은 클로저나 프로퍼티를 추가할 수 있다. 타입 선언부외에 Swift의 익스텐션으로 기능을 추가할 수 있지만,저장 프로퍼티를 추가할 수 없게 되어있다. 저장 프로퍼티를 추가하거나, UIKit에 이미 만들어져있는 객체에 간단하게 클로저를 붙여주고 싶을 때 이런 상황을 우회하기 위해서 쓰기도 한다. (https://medium.com/@serhatsezer/your-old-friend-associated-object-in-swift-bb8e105ee633)

UIButton에 클로저를 추가해 보았습니다.(https://jintaewoo.tistory.com/53)

발표에 나온 코드를 보자.


```swift
final class DeallocHooker {
    private struct AssocciatedKey {
        static var deallocHookcer = "deallocHooker"
    }
    
    private let handler: () -> Void
    private init(_ handler: @escaping () -> Void) {
        self.handler = handler
    }
    
    deinit {
        handler()
    }
    
    static func install(to object: AnyObject, _ handler: @escaping () -> Void) {
        objc_setAssociatedObject(
            object,
            &AssocciatedKey.deallocHookcer,
            DeallocHooker(handler),
            .OBJC_ASSOCIATION_RETAIN_NONATOMIC
        )
    }
}
```

이 객체가 바로 String에 찰싹 달라붙어서 우리가 원하는 뒤처리를 해줄 친구이다.

`install()`이라는 메서드에서 특정한 객체와 클로저를 파라미터로 받는다. 그리고 해당 클로저를 핸들러로 가지는 DeallocHooker를 생성해, 특정 객체에 붙여준다.

'연관 객체' 인스턴스는 붙여준 객체가 '해제'가 되면 더 이상 참조가 없어지기 때문에 같이 해제가 된다. 

String이 메모리에서 해제되면, 연관 객체였던 DeallocHooker도 같이 메모리에서 해제된다. 그러면 DeallocHooker는 해제가 되기 전, deinit 안에 선언해준 handler 클로저를 실행한다. 

그렇다면 handler 클로저에, 자연스럽게 해당 객체가 갖고 있는 메모리를 지우는 코드를 넣어주면, String이 해제될 때 메모리를 지우는 코드도 같이 실행될 것이다!

간단하게 요약하자면, String이 해제되면 DeallocHooker의 클로저가  실행되도록 만든 것이다. String의 코드를 전혀 건드리지 않고 associated object만 사용해서.

하지만 associated object는 obj-c 기능이고, 당연하게도 Class (NSObject)의 하위 클래스밖에 사용하지 못한다. 따라서 토스 팀은 Struct로 만들어진 String 객체는 이 방법을 사용하지 못하고, 대신 거의 비슷한 기능을  가졌지만 Class로 만들어진 NSString을 사용했다고 한다.

왜 굳이 associated object를 썼을까?

이 부분에서 또 하나의 의문이 생겼다. 왜 NSString을 서브클래싱하거나, NSString을 감싸는 컨테이너 객체를 만들지 않았을까? 컨테이너 객체를 만들면 NSString이 가진 메서드를 사용하지 못하기 때문일까? 그렇다면 NSString을 서브클래싱하면 되지 않았을까? 서브클래싱을 해서 deinit 안에 memset으로 초기화하는 코드를 넣어주면 될 것 같은데. obj-c 런타임을 사용하는 것보다 (적어도 나에게는) 좀 더 직관적인 해결책이다. 

애플의 NSString 문서에 있는 서브클래싱 관련 언급이다. 

Valid reasons for making a subclass of NSString include providing a different backing store (perhaps for better performance) or implementing some aspect of object behavior differently, such as memory management.

마지막 문장은 우리가 하려는 메모리 흔적 지우기와 매우 통하는 것 같다.하지만 저 이상으로는 아무리 구글링을 해봐도 잘 나오지는 않는다.

뭔가 이유가 있었던 걸까? 내 얕은 지식으로는 잘 모르겠다. (혹시 짐작가시는 분은 댓글로 달아주시길)

## 버퍼가 뭐지?

발표에서 또 하나 익숙하지 않았던 개념이 '버퍼(Buffer)'였다. 버퍼는 연속적인 메모리 공간을 가리키는 포인터다. 이 버퍼(포인터)를 가지고 어떤 메모리 덩어리에 들어있는 값을 읽거나, 변경할 수 있다.

Swift 코딩을 하면서, 이런 포인터를 직접 다룰 일은 잘 없다. 프로그래머가 메모리를 직접 건드리지 않기 때문이다.

하지만 Swift에도 C 언어의 포인터 기능이 있다. `UnsafePointer` 관련 타입이다. 포인터를 다룰 수 있는 Swift 객체다. 

Unsafe-라는 무시무시한 이름이 붙어있는데, Swift 컴파일러가 제공하는 안전 기능에 해당되지 않는다는 뜻이다.

발표에 나온 코드를 보면, `Int8` 타입의 UnsafeMutablePoint를 원하는 bufferSize 만큼 할당한다.

```swift
let buffer = UnsafeMutablePointer<Int8>.allocate(capacity: bufferSize)
```

Int8 타입의 데이터가 bufferSize만큼 들어갈 만큼의 새로운 메모리 공간을 할당하고 그 포인터를 넘겨준 것이다.

이 포인터를 사용해서 NSString을 생성하고, 동시에 아까 말했던 Hooker의 핸들러에 사용할 수 있다. Handler는 NSString이 존재하는 힙의 메모리 주소에 접근할 수 있게 된다. memset이라는 초기화 함수로 해당 영역의 메모리를 모두 0으로 바꿔버린다. 

드디어 흔적을 남기지 않는 String을 만들게 되었다.

## String이 차지하는 메모리 길이

여기서 내 눈에 띈 코드는 한 줄은 BufferSize를 구하는 부분이다. 메모리 공간을 직접 할당하려고 하니 사이즈를 구해야 한다.
당연히 우리가 생성하려고 하는 String의 사이즈만큼 만들어줘야 한다. 

```swift
let bufferSize = string.maximumLengthOfBytes(using: encoding) + 1
```

'+1'을 해주는 부분은, String의 마지막에는 끝을 나타내기 위해 'null'문자가 들어가기 때문이다.

사이즈를 구하기 위해 String의 글자 길이를 구하지 않고 maximumLengthOfBytes 라는 함수를 쓴다.

이것은 Swift String의 특성과 상관이 있다. 

Swift는 모든 유니코드 글자를 지원한다. 보통 우리가 어떤 문자를 이진수로 표현할 때는, 문자에 해당하는 '코드'를 매핑해서 사용하게 되는 데, 이 문자 코드의 전세계 표준이 바로 유니코드다.

그런데 알파벳 외에도 수많은 문자가 있다. é 는 e와 완전히 다른 문자다. 이 문자는 e를 뜻하는 101과 '를 뜻하는 769를 합쳐서 표현할 수 있다. 이모지도 이 문자에 포함이 된다. 엄지를 뜻하는 128077과 검은 피부색을 뜻하는 127997을 조합하면 검은 엄지 척이 된다.

이런 식으로 2개의 코드를 조합해 하나의 글자를 만드는 방식을 유니코드 표준에서는 그래핌 클러스터(Grapheme Cluster)라고 한다.

Swift의 String은 이 그래핌 클러스터 글자까지도 일반 글자와 똑같이 사용할 수 있도록 '표준화'를 시킨다. Swift에서 String 타입이 포함하고 있는 데이터(Character)의 갯수와, 따라서 메모리에 저장되는 코드 포인트의 갯수는 서로 다르다. (Swift를 처음 배우면 당황 스러운 부분이, String이 글자의 콜렉션임에도 불구하고, String[1] 같이 정수로 원소에 접근하는 게 불가능하다는 점인데, 바로 이 유니코드 표준을 지키기 위한 Apple의 디자인 철학과 관련이 있다.)

아무튼 바로 이런 이유 때문에 Swift string에는 글자 수와 다르게 maximumLengthOfBytes 값이 존재하고, 우리는 지금 메모리의 사이즈를 알고 싶은 것이니까 이걸 사용해줘야 한다.
























