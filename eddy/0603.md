- 메모리에 남지 않는 문자열
    - Intro
        - 작년 토스 개발자 컨퍼런스중에서 '메모리에 남지 않는 문자열'이라는 영상을 봤다.
        - 안전하게 비밀번호를 저장하는 건 무척 궁금했던 주제라 시간을 내서 영상을 봤다.
        - 메모리에 남지 않는 건 아니고, 메모리에서 String의 흔적을 모두 지워준다는 뜻이었다.
        - 보면서 모르는 부분도 있고, 헷갈리는 부분도 있어서 더 공부를 해봤다.
        - 복습해볼겸 정리를 해보고자 한다.
    - 문제 개요
        - 간략하게 배경설명을 하자면, 금융앱이니만큼 사용자의 금융 정보가 String으로 입력된다.
        - 이 String을 조작하거나 복사를 하고 나면 메모리 상에 이 String 데이터의 흔적이 남게 된다.
        - 메모리 전체를 Dump를 떠서 봤을 때 해커가 비밀번호를 볼 수도 있는 것이다.
        - 암호화된 별도의 저장 String을 쓰고 있었다. 암호화된 String의 사용성을 높이지 않으면, 한번이라도 String을 쓰면 어차피 사용자 입력은 메모리에 등장하게 된다.
    - 왜 Value type인데 힙에 저장되는가?
        - Swift의 Collection은 대부분 힙에 저장된다.
        - String은 각 글자, 즉 Character 타입의 데이터가 모여있는 컬렉션이다.
        - 배열처럼 for 문도 쓸 수 있다.
    - 메모리를 해제해도 데이터가 사라지는 게 아니라고? (Garbage Value)
    - String은 왜 계속해서 흔적을 남길까? 
        - 힙에 있는 인스턴스는 한번 생성이 되고 나면, 참조만 공유된다.
        - String은 저장되고 나서 계속 복사를 반복한다.
        - String을 조작하게 불변성을 유지하기 위해서 계속 복사가 일어난다.
        - 메모리를 그때그때 지워줘야 한다. 
    - Assciated Object란 무엇일까?
        - Assciated Object는 Obj-c 런타임에서 작동하는 기능이다.
        - Swift에서도 쓸 수 있다.
        - 특정한 객체에 다른 객체를 '붙여'놓을 수 있다. 
        - 다른 말로 하면 적용한 객체에 임의의 행동을 추가해줄 수 있다.
        - 붙여놓은 객체에 어떤 액션이 트리거 된다면, 연관 객체에서도 특정한 클로저가 실행이 되도록 할 수 있다.
        - 이미 있는 객체의 코드를 수정하거나, 서브클래싱을 하지 않고서, 행동을 변화시키고자 할 때 쓸 수 있는 약간 해킹(?) 스러운 기법이다.
        - 토스 팀은 String 객체에다가, Hooker라고 해서 String 객체의 할당이 해제될 때마다, Hoocker도 같이 해제가 되고, Hoocker가 해제될 때 (deinit) 저장해놓은 특정한 함수를 실행시키는 객체를 붙여두었다.
        - 쉽게 말해 String이 해제되면 클로저가 호출되도록 했다. String을 전혀 건드리지 않고 말이다.
        - 문제는 Swift의 String에는 
        - 이 부분에서 좀 이해가 안됐던 점이 있다. 그럴거면 왜 위에서 COW랑 String을 잔뜩 설명했지? 라는 거였다. 어차피 NSString은 클래스이고 Reference type이다. 내용은 당연히 힙에 저장이 된다. Swift String에 대해 설명한 이유가 사라지는 느낌이었다.
        - 또 하나의 의문이 있었다. NSString을 서브클래싱해서 만들면 되는 거 아닐까? 왜 굳이 이런 방법을 썼을까? 뭔가 기존 시스템과의 호환성을 위해서 NSString을 서브 클래싱하면 안되는 상황이었던 걸까?
    - '버퍼'라는 게 뭐지?
        - 버퍼, 바이트 버퍼라는 말이 나온다.
        - 버퍼라는 말을 메모리 관련해서 많이 듣긴 하는데 정확한 개념을 모르고 있었다.
        - 버퍼는 연속적인 메모리 공간을 가리킨다.
        - 어떤 메모리의 덩어리를 의미하는데, 이 버퍼는 우리가 직접 메모리의 값을 읽고, 쓸 수 있는 포인터다.
        - C 언어의 포인터와 같다.
        - Swift는 자동으로 메모리를 관리해준다. 따라서 우리가 평소 코딩에서 이런 포인터를 보거나 포인터를 사용해서 메모리를 읽고 쓸 일은 자주 없다.
        - 하지만 Swift에서도 C 언어 포인터를 제공한다.
            - C로 구현된 함수를 쓸 일이 있거나, 직접 메모리에 접근할 수 있다.
            - 정확히 말하면 Swift 언어는 포인터를 다룰 수 있는 ‘컨테이너' 객체를 제공한다.
            - 총 9개의 종류가 있다.
        - Unsafe-라는 무시무시한 이름이 붙어있다. 
        - Swift가 제공하는 여러 안전기능을 쓰지 않고, 직접 메모리에 접근한다는 뜻이다.
        - 아무튼 토스 팀이 짠 코드를 보면, 직접 <Int8>타입의 UnsafeMutablePoint을 만든다. 그리고 거기다가 글자를 넣어준다. 
        - mutable이 붙어있기 때문에 포인터를 통해서 메모리의 내용을 수정할 수 있다.
        - 그리고 이 버퍼를 그대로 사용해서 String을 만들어주고, 그 참조를 리턴해주는 것이다.
        - 이 버퍼는 아까 말했던 Hooker의 핸들러에 집어넣을 수 있다.
        - 우리는 이 NSString이 존재하는 힙의 메모리 주소를 알 수 있고, 나중에 memset이라는 명령어로 싹 해재를 해줄 수 있게 된다.
    - String의 길이가 메모리의 길이와 다른 이유는 뭐지?
        - 버퍼를 만들 때 버퍼의 사이즈가 필요하다. 
        - 당연히 우리가 생성하려고 하는 String의 사이즈만큼 만들어줘야 할텐데 이때 string.count가 아닌, string.maximumLengthOfBytes 라는 함수를 사용한다.
        - Swift의 Character은 Unicode를 모두 지원한다. 즉, String은 유니코드 글자로 이뤄져있다.
        - 근데 이 유니코드라는 건 세상의 모든 문자를 표현할 수 있는 거고, 세상에는 단순히 영어 알파벳 뿐만 아니라 수많은 문자들이 있다. 
        - é 는 e와 완전히 다른 문자다. 이 문자는 e를 뜻하는 101과 '를 뜻하는 769를 합쳐서 표현한다.
        - 이모지도 이런식으로 많이 조합을 한다. 엄지를 뜻하는 128077과 검은 피부색을 뜻하는 127997을 조합하면 검은 엄지 척이 된다.
        - 이런 식으로 2개의 글자를 섞어서 글자를 만드는 방식을 유니코드 표준에서는 그래핌 클러스터(Grapheme Cluster)라고 한다.
        - 따라서 Swift에서 하나의 Character는 고정된 사이즈가 아니라, 여러 코드의 조합이 가능하다.
        - String은 메모리에 Unicode code point의 콜렉션으로 접근이 된다.
        - 하지만 서로 같은 글자를 표현하더라도 코드 포인트는 서로 다를 수가 있다.
        - 스위프트는 조합 캐릭터와 일반 캐릭터를 똑같이 취급하기 위해서 표준화를 사용한다.
        - Swift가 정수를 가지고 인덱싱을 할 수 없는 이유이기도 하다.
        - 아무튼 string이 차지하는 메모리 사이즈를 알기 위해서는 저렇게 별도의 함수를 써줘야 한다.