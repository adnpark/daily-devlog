# [업그레이더블 컨트랙트 씨-리즈] Part 3 - 비콘 프록시 컨트랙트 해체 분석하기

Created: 2022년 6월 21일 오전 2:13

## **[업그레이더블 컨트랙트 씨-리즈 목차]**

Part 1 — [업그레이더블 컨트랙트란?](https://medium.com/@aiden.p/%EC%97%85%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%8D%94%EB%B8%94-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8-%EC%94%A8-%EB%A6%AC%EC%A6%88-part-1-%EC%97%85%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%8D%94%EB%B8%94-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8%EB%9E%80-b433225ebf58) 

Part 2 — [프록시 컨트랙트(Proxy Contract) 해체 분석하기](https://medium.com/@aiden.p/%EC%97%85%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%8D%94%EB%B8%94-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8-%EC%94%A8-%EB%A6%AC%EC%A6%88-part-2-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%BB%A8%ED%8A%B8%EB%9E%99%ED%8A%B8-%ED%95%B4%EC%B2%B4-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0-95924cb969f0)

***Part 3 — 비콘 프록시 컨트랙트(Beacon Proxy Contract) 해체 분석하기 (이번 글)***

Part 4 — 미니멀 프록시 컨트랙트(Minimal Proxy Contract) 해체 분석하기

## 들어가며

Part 1, 2를 통해 업그레이더블 컨트랙트, 그리고 이를 가능하게 해주는 다양한 프록시 패턴에 대해 살펴보았다. 그리고 나름의 베스트 프랙티스도 학습하였다. (기억이 나지 않는다면 Part 2 요약 부분(TODO: add link)을 다시 복습해보자)

아주 기분 좋은 소식이 하나 더 있다. 바로 기존의 비효율을 개선할 수 있는 또 하나의 패턴이 있다는 것이다. 이를 자세히 살펴보기 전에 먼저 실제로 일어날법한 상황속으로 들어가보자.

TODO: add picture, some dao image?

여러분은 신임 테크 리드로 xyz DAO에 합류했다.

xyz DAO는 원하는 DAO를 손쉽게 배포할 수 있는 서비스를 커뮤니티에 제공하는 프로젝트이다.

마침 여러분이 합류하기 직전 xyz DAO의 커뮤니티는 거버넌스 포럼을 통해 새로운 기능이 포함된 DAO 배포용 컨트랙트를 만들기로 결정하였다.

커뮤니티 모더레이터는 여러분에게 아래와 같이 커뮤니티의 피드백을 전달했다.

“새롭게 배포되는 DAO 컨트랙트는 **업그레이드가 가능**했으면 좋겠어요. 중간에 커뮤니티 피드백을 빠르게 반영해서 업데이트할 수 있으면 좋을것 같아요. 아! 그리고, 기존에는 DAO를 **배포할 때마다 새롭게 컨트랙트를 배포**했었는데, 가스비가 너무 많이 든다는 피드백이 있었어요. 가스 수수료를 줄일 수 있는 방법을 찾아보면 좋을것 같아요.”

요약해보면 요구사항은 다음과 같다.

1. 새로운 컨트랙트를 업그레이더블 컨트랙트로 만든다.
2. 가능한 컨트랙트 배포 비용을 낮춘다.

먼저 이전의 컨트랙트 구조를 살펴봤더니 아래와 같았다.

TODO: add figure

팩토리 컨트랙트 → (배포) → DAO 컨트랙트

단순하게 사용자의 호출이 있을때마다 new 키워드를 이용해서 새로운 DAO 컨트랙트를 배포하는 방식이었다. 이는 첫째로, 업그레이더블 하지도 않으며, 둘째, DAO 컨트랙트 배포 비용또한 매우 높다.

자 이런 상황에서 여러분은 xyz DAO의 테크 리드로써 새로운 DAO 컨트랙트를 어떻게 설계할 것인가?

잘 생각해보면 part 1,2에서 배웠던 프록시 패턴

하지만 여기서 놓친것이 하나 있다. 만약 이렇게 배포된 컨트랙트를 업그레이드하려면? 배포된 모든 프록시 컨트랙트에서 upgradeTo() 함수를 호출하여 새로운 DAO 로직 컨트랙트로 업그레이드 해줘야 한다. 

“*먼저 컨트랙트 배포 비용이 비싸다. → 비용을 줄이고 싶다 → 프록시 패턴을 활용하여 로직 컨트랙트를 재활용하면 줄일 수 있다” 의 흐름으로 작성하면 좋을듯*

- 프록시 패턴의 장점은 업그레이더블에 있기도 하지만, 코드의 재사용성 또한 큰 장점이다.
- 프록시 패턴의 핵심은 로직 컨트랙트에 실행을 위임하는 것이다. 그것이 계속해서 살펴본 delegatecall의 핵심이다.
- 여기서 주목해야 할 점은 로직 컨트랙트에 실행을 위임하는 프록시 컨트랙트는 단 하나만 존재할 이유가 없다는 것이다.
- 이 점을 잘 활용하면 프록시 패턴을 업그레이더블 컨트랙트 뿐만 아니라, 컨트랙트 배포의 관점에서도 효율성을 배가시킬 수 있다.
- 컨트랙트의 구현 복잡도에 따라 다르지만, 대체로 컨트랙트를 배포할 때 상당히 많은 가스가 소모되고 이로 인해 배포 비용이 매우 높다.
- 이 글이 작성되고 있는 시점은 이더의 가격이 많이 내려와 있지만, 가격이 약 3~400 만원에 육박할 때는 컨트랙트만 배포만 해도 수백만원(…)이 날라가는 기적을 볼 수 있었다.
- 때문에 개발자 입장에서 컨트랙트 내부의 동작을 효율적으로 구현하는것도 중요하지만, 컨트랙트 배포 비용또한 가급적 줄일 수 있으면 좋다.
- 이러한 니즈를 프록시 패턴이 해결해줄 수 있는데, 바로 동일한 로직 컨트랙트를 재사용하는 것이다.
- ㅅ

- 예를 들어, 동일한 ERC20 토큰 컨트랙트를 10000개 배포해야 한다고 가정해보자.
- 그리고 편의상 토큰 컨트랙트 배포에 필요한 Gas는 500000, Gas Price는 $0.00005 (ETH Price $1250, 약 40 Gwei 기준)라고 가정해보자.
- 토큰 컨트랙트 배포에 필요한 비용은 $25 가 된다.
- 하나 정도는 배포할만 하겠지만, 만약에 동일한 컨트랙트를 10000개 배포한다면?
- 비용은 $250,000가 되며 한화로 약 3억원이 넘는 금액이 된다.
- 물론 실제로 동일한 컨트랙트를 10000번이나 배포하는게 현실에서 얼마나 많을지는 모르겠지만, 이만큼 많은 비용이 소모된다는점은 시사할만하다.
- 이를 효율적으로 할 수 있는 방법이 프록시 패턴을 활용하는 것
- 프록시 패턴의 핵심은 컨트랙트 실행의 위임에 있음
- 이는 업그레이드뿐만 아니라 다른 형태로도 활용 가능
- 로직 컨트랙트 하나만 배포해두고 동일한 로직을 사용하는 컨트랙트는 모두 프록시 컨트랙트로 구현한 뒤, 해당 로직 컨트랙트를 가리키도록 한다면?
- 복잡한 로직 컨트랙트를 배포하는 비용을 아주 단순한 프록시 컨트랙트 배포하는 비용으로 줄일 수 있다.
- TODO: 그림 추가 - 다수의 프록시 컨트랙트가 동일한 로직 컨트랙트를 가르키는 모습
- 이러한 목적으로만 프록시 패턴을 사용하는것을 Minimal Proxy라고 하는데, 이는 다음 글에서 자세히 살펴보자.
- 여기까진 모든게 다 좋아보인다.

비콘 프록시

- 기존에 배포해놓은 토큰 로직 컨트랙트에 문제가 생겨 새로운 버전으로 업그레이드 해야 하는 상황
- 그러면 어떻게 하는가? 10000개의 프록시 컨트랙트를 한땀한땀 upgradeTo()를 호출해가는 수 밖에 없다.
- 즉 10000번의 업그레이드 실행 트랜잭션이 필요하다.
- 무언가 비효율적인 느낌이 들지 않는가?
- 이 비효율을 개선하고자 나온게 바로 비콘 프록시이다.
- 비콘 프록시는 프록시와 로직 컨트랙트 사이에 비콘 컨트랙을 하나 더 둔다.
- 비콘이라는 단어의 사전적 의미는 다음과 같다.
    - 봉화나 등대와 같이 위치 정보를 전달하기 위해 어떤 신호를 주기적으로 전송하는 기기
- 즉, 비콘 컨트랙트는 말 그대로 어떤 로직 컨트랙트를 호출해야 하는지를 알려주기 위한 지표로써 역할한다.
- 프록시 컨트랙트는 항상 비콘 컨트랙트에게 어떤 로직 컨트랙트를 호출해야 하는지 물어본다.
- TODO: 프록시 - 비콘 - 로직 다이어그램
- 아까의 예시에서 업그레이드를 하려면?
- 더 이상 10000번이나 트랜잭션을 날릴 필요가 없다.
- 그냥 비콘 프록시에서 로직 컨트랙 주소만 바꿔주면 끝이다!
- O(n)이 O(1)으로 줄어드는 기적!
- 그러면 비콘 프록시는 신이고 무적인가?
- 그렇지 않다. 비콘 프록시 또한 단점이 명확하다.
- 프록시 패턴 자체가 컨트랙을 한번 거쳐서 실행하는 패턴이기 때문에 가스 비효율이 어느정도 발생하게 되는데, 비콘 프록시는 더 심하다.
- 이건 두번 거치는 꼴이니 비용이 그만큼 더 발생하게 된다.

- 비콘 프록시는 바로 로직 컨트랙트의 주소를 저장하지 않음
- 현재 버전의 로직 컨트랙트의 주소를 알려주는 비콘 컨트랙트 주소를 저장함
- TODO: BeaconProxy.sol 코드 추가
- TODO: UpgradeableBeacon 코드 추가

언제 비콘 프록시를 쓰는가?

- 동일한 로직을 사용하는 대규모의 컨트랙트를 동시에 업그레이드 해야할 필요성이 있는 경우
- 개인별 고객의 자산을 관리하는 Vault 컨트랙트가 있다.
- Vault 컨트랙트는 어카운트별로 새롭게 배포된다.
- 모든 Vault 컨트랙트의 로직은 동일하다.
- 추후 Vault 컨트랙트의 기능을 업그레이드하거나, 보안 이슈가 발생했을 때 바로 대응할 수 있어야 한다.ㅇ

요약

- 동일한 로직을 사용하는 컨트랙트를 대규모로 배포하고 동시에 업그레이드 가능하게 하려면 비콘 프록시를 사용하자
- 비콘 프록시는 무적이 아니다. 기존 프록시 패턴에 비해 컨트랙트 함수 호출에 필요한 레이어가 하나 더 추가된다. 가스 부담이 발생한다.
- 만약 동일한 로직의 컨트랙트를 대규모로 효율적으로 배포하는것 자체에만 관심이 있다면, 다음 글 미니멀 프록시를 참고해보자.

더 읽어보기

- ****Proxy Patterns For Upgradeability Of Solidity Contracts: Transparent vs UUPS Proxies****

[https://mirror.xyz/0xB38709B8198d147cc9Ff9C133838a044d78B064B/M7oTptQkBGXxox-tk9VJjL66E1V8BUF0GF79MMK4YG0](https://mirror.xyz/0xB38709B8198d147cc9Ff9C133838a044d78B064B/M7oTptQkBGXxox-tk9VJjL66E1V8BUF0GF79MMK4YG0)

[https://mixbytes.io/blog/collisions-solidity-storage-layouts](https://mixbytes.io/blog/collisions-solidity-storage-layouts)

[https://blog.logrocket.com/creating-contract-factory-clone-solidity-smart-contracts/](https://blog.logrocket.com/creating-contract-factory-clone-solidity-smart-contracts/)

- [https://twitter.com/smpalladino/status/1389939156525232130](https://twitter.com/smpalladino/status/1389939156525232130)

[https://blog.openzeppelin.com/the-transparent-proxy-pattern/](https://blog.openzeppelin.com/the-transparent-proxy-pattern/)